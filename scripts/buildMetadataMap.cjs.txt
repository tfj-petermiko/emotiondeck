const fs = require("fs");
const path = require("path");

const metadataDir = path.join(process.cwd(), "content", "metadata");
const outputFile = path.join(process.cwd(), "app", "metadataMap.json");

// 🧩 Parse each metadata .txt file
function parseTxt(filePath) {
  const content = fs.readFileSync(filePath, "utf-8");
  const lines = content.split("\n");
  const data = {};
  let key = "";

  for (const line of lines) {
    if (line.startsWith("#")) {
      key = line.replace("#", "").trim();
      data[key] = "";
    } else if (key && line.trim() !== "") {
      data[key] += (data[key] ? "\n" : "") + line.trim();
    }
  }

  return data;
}

// 🔁 Recursively build map from folders
function buildMetadataMap(dir, basePath = "") {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  const map = {};

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    const routePath = path.join(basePath, entry.name);

    if (entry.isDirectory()) {
      Object.assign(map, buildMetadataMap(fullPath, routePath));
    } else if (entry.name.endsWith(".txt")) {
      const route = "/" + routePath.replace(/\\/g, "/").replace(/\.txt$/, "");
      map[route] = parseTxt(fullPath);
    }
  }

  return map;
}

// 🚀 Main builder
function main() {
  if (!fs.existsSync(metadataDir)) {
    console.error(`❌ Directory not found: ${metadataDir}`);
    process.exit(1);
  }

  const metadataMap = buildMetadataMap(metadataDir);

  // Sort routes alphabetically
  const sortedMap = Object.keys(metadataMap)
    .sort()
    .reduce((acc, key) => {
      acc[key] = metadataMap[key];
      return acc;
    }, {});

  fs.writeFileSync(outputFile, JSON.stringify(sortedMap, null, 2), "utf-8");

  console.log(
    `✅ metadataMap.json generated with ${Object.keys(sortedMap).length} routes.`
  );
}

main();
